{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/my-first-post/","result":{"data":{"markdownRemark":{"html":"<p class=\"para\">The first topic of the series is something that forms the basis of how we write code - data structures.</p>\n<blockquote>\n<p class=\"para\">A data structure is a particular way of organizing data in a computer so that it can be used efficiently.</p>\n</blockquote>\n<p class=\"para\">This blog post focuses on Data Structures that the Android run time system provides in order to make your apps more efficient. These data structures were built keeping Android in mind and hence the knowledge of these are essential for every Android developer.</p>\n<h1 class=\"heading\">ArrayMap</h1>\n<p class=\"para\"><a href=\"https://developer.android.com/reference/android/support/v4/util/ArrayMap.html\" class=\"url\">ArrayMap</a> is a generic key->value data structure that is similar to HashMap in functionality but is meant to be more memory efficient.</p>\n<p class=\"para\">Let's dive into the internals of an ArrayMap. The ArrayMap contains two small arrays instead of one that is seen in the case of a HashMap. The first array contains the hashes of the given keys in sorted order. The second array stores the key and value objects in a contiguous fashion based on the ordering of the first array.</p>\n<!-- ![ArrayMap](https://blog.vinaygaba.com/images/ArrayMap.png) -->\n<p class=\"para\">When the value for a key needs to be fetched, the key is first hashed and that hash is binary searched to find the index of that hash. This index is then used to find the location of the key and value in the interwoven array.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Key</span> <span class=\"token class-name\">Index</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HashIndex</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code></pre></div>\n<p class=\"para\">Example usage:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ArrayMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> arrayMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\narrayMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> value <span class=\"token operator\">=</span> arrayMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p class=\"para\">If the key does not match the key we were searching the value for, a linear search is performed in both the directions as it is assumed this was a case of collision.As the number of objects grow, so does the time to access a single object. Hence, the tradeoff is between smaller memory overhead for more expensive runtime access. Another advantage of using an ArrayMap over a HashMap is that it allows iteration over the collection using indexing which is not possible when using a HashMap. If the key does not match the key we were searching the value for, a linear search is performed in both the directions as it is assumed this was a case of collision.As the number of objects grow, so does the time to access a single object. Hence, the tradeoff is between smaller memory overhead for more expensive runtime access.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrayMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">String</span> key <span class=\"token operator\">=</span> arrayMap<span class=\"token punctuation\">.</span><span class=\"token function\">keyAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">String</span> value <span class=\"token operator\">=</span> arrayMap<span class=\"token punctuation\">.</span><span class=\"token function\">valueAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p class=\"para\">As you might remember from this Android Performance Patterns episode, <a href=\"https://www.youtube.com/watch?v=MZOf3pOAM6A\" class=\"url\">To Index or Iterate?</a>, using the index to iterate over a collection is more performant compared to using an iterator.</p>\n<h2 class=\"subheading\">When to use ArrayMap?</h2>\n<p class=\"para\">It is suitable to use ArrayMaps in the following situations:</p>\n<ul>\n<li>When there are &#x3C; 1000 objects in the collection</li>\n<li>When insertion and deletions are infrequent.</li>\n<li>When there are nested maps and sub maps have lower number of items and you often iterate over them.</li>\n</ul>\n<h1 class=\"heading\">SparseArray</h1>\n<h1 class=\"heading\">The Next Morning</h1>\n<p class=\"para\">Autoboxing could be a huge memory problem for your applications. One of the largest causes of Autoboxing issues are HashMap containers. HashMap's enforce you to use objects instead of primitives. Autoboxing also happens when you fetch a primitive object from a primitive container. Example :</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p class=\"para\">In addition, generic objects are much larger in size than their primitive counterparts. For example an Integer takes 16 bytes of space whereas its primitive counterpart takes just 4 bytes. Hence it would be much more efficient if you could use primitives as either keys or values in collections.</p>\n<p class=\"para\">The <a href=\"https://developer.android.com/reference/android/util/SparseArray.html\" class=\"url\">SparseArray</a> family of data structures aims to do just that. The Android run time provides this class to use primitives instead of generics as keys or values. The following classes are available in Android:</p>\n<!-- <table>\n  <tr>\n    <td>SparseBooleanArray</td>\n    <td> (int, boolean) </td>\n  </tr>\n\n  <tr>\n    <td>SparseArray</td>\n    <td> (int, obj) </td>\n  </tr>\n\n  <tr>\n    <td>SparseLongArray</td>\n    <td> (int, long) </td>\n  </tr>\n\n  <tr>\n    <td>LongSparseArray</td>\n    <td> (long, obj) </td>\n  </tr>\n\n  <tr>\n    <td>SparseIntArray</td>\n    <td> (int, int) </td>\n  </tr>\n\n</table> -->\n<p class=\"para\">Example usage:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">SparseArray</span> sparseArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SparseArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsparseArray<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Android\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">SparseLongArray</span> sparseLongArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SparseLongArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsparseLongArray<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">SparseBooleanArray</span> sparseBooleanArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SparseBooleanArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsparseBooleanArray<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">SparseIntArray</span> sparseIntArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SparseIntArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsparseIntArray<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">LongSparseArray</span> longSparseArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LongSparseArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlongSparseArray<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Android\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p class=\"para\">Similar to ArrayMaps, SparseArray's help in reducing the memory footprint. The internal of them are very similar as well and both of them contain two tightly packed arrays rather than one. It also makes use of binary search like in the case of ArrayMaps</p>\n<h2 class=\"subheading\">When to use SparseArray?</h2>\n<p class=\"para\">The SparseArray can be used for the same scenarios that you can use an ArrayMap for.Having said that, the main difference between SparseArray and ArrayMap is that the key object is always of primitive type in case of a SparseArray. This has two folds benefits as you save on memory and also avoid autoboxing.</p>\n<h1 class=\"heading\">Creating your own Data Structure</h1>\n<p class=\"para\">It's possible that the existing data structures might not be sufficient for your use case. In such a scenario it would make sense to use something custom in order to make your app more memory efficient. One such example was what Facebook used in order to make the feeds(news feed, profiles, events, groups) in their main app to be more memory efficient. They noticed that inserting long values in a HashSet was resulting in memory leaks and so they decided to create a custom data structure called a LongArraySet which worked similar to a Set and used a LongSparseArray as the internal map instead of a HashMap. I would highly recommend reading that <a href=\"https://code.facebook.com/posts/857070764436276/memory-optimization-for-feeds-on-android/\" class=\"url\">article</a>. The source code for LongArraySet can be found <a href=\"https://code.facebook.com/posts/973222319439596\" class=\"url\">here</a>.</p>","frontmatter":{"slug":"/writing/my-first-post","title":"My first blog post"}}},"pageContext":{"id":"d97e29cc-f096-5720-be76-fa1b34fa9f83","frontmatter__slug":"/blog/my-first-post","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":[]}